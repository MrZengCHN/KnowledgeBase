Java 中的 `HashMap` 是面试中常被问到，也是我们在实际开发中使用频率最高的数据结构之一。它的底层原理非常精妙。

以下是基于 Java 8 及以上版本的 `HashMap` 原理剖析：

### 1. 底层数据结构

在 Java 8 中，`HashMap` 的底层数据结构是 **数组 + 链表 + 红黑树**。

- **数组（Node[] table）：** 这是 `HashMap` 的主体，用于存储元素。数组的特点是寻址容易，插入和删除困难。
- **链表：** 主要为了解决**哈希冲突**（Hash Collision）。当不同的 Key 经过哈希计算后映射到了数组的同一个位置时，这些元素就会以链表的形式存储在这个位置上。
- **红黑树：** 在 Java 8 中引入的优化机制。当链表过长（查找效率从 $O(1)$ 退化为 $O(n)$）时，链表会转换为红黑树，将查找的时间复杂度优化到 $O(\log n)$。

### 2. 核心机制解析

#### A. 哈希算法与扰动函数

当我们向 `HashMap` 中存入一个键值对时，它首先会调用 Key 的 `hashCode()` 方法获取一个 32 位的整型哈希值。为了减少哈希冲突，`HashMap` 会对这个值进行**扰动（高低位异或）**：

```
hash = (h = key.hashCode()) ^ (h >>> 16)
```

这样做的目的是混合原始哈希码的高位和低位，以此来加大低位的随机性，使得数据分布更均匀。

#### B. 索引计算

得到 `hash` 值后，`HashMap` 并不是直接用它作为数组下标，而是通过以下公式计算下标：

`index = (n - 1) & hash` （其中 `n` 为数组的长度）

这也是为什么 **`HashMap` 的数组长度必须是 2 的整数次幂**的原因。当 `n` 是 2 的次幂时，`(n - 1) & hash` 等价于 `hash % n`（取模运算），但位运算（`&`）的效率要远远高于取模运算。

### 3. `put()` 方法的核心工作流程

当你调用 `map.put(key, value)` 时，大致经历了以下步骤：

1. **计算 Hash：** 对 Key 计算其 hash 值。
2. **初始化数组：** 如果 `HashMap` 的数组尚未初始化（或为空），则进行第一次扩容（默认初始容量为 16）。
3. **计算索引：** 通过 `(n - 1) & hash` 找到在数组中的对应桶（Bucket）位置。
4. **处理节点：**
   - **位置为空：** 如果该位置没有元素，直接将新建的节点放入。
   - **发生冲突：** 如果该位置已经有元素了（即发生了哈希冲突）：
     - **判断 Key 是否相同：** 如果当前节点的 Key 和要插入的 Key 完全一致（`hash` 相同且 `equals()` 为 `true`），则直接用新 Value 覆盖旧 Value。
     - **红黑树节点：** 如果当前节点已经是红黑树节点，则调用树的插入方法将元素插入红黑树中。
     - **链表节点（尾插法）：** 如果是链表，则遍历链表。如果发现相同的 Key 则覆盖；如果遍历到链表尾部都没有发现相同的 Key，则将新节点插入到链表尾部。
5. **树化判断（Treeify）：** 在链表尾部插入新节点后，如果**链表长度达到 8**，并且**数组总容量达到 64**，则将链表转化为红黑树，以提升检索速度。
6. **扩容判断（Resize）：** 插入成功后，如果 `HashMap` 中的元素总数超过了阈值（`threshold = capacity * loadFactor`，默认负载因子为 0.75），则触发扩容。

### 4. 扩容机制（Resize）

随着元素的不断增加，哈希冲突的概率会越来越高。为了保证查询效率，`HashMap` 会进行扩容。

- **什么时候扩容？** 当元素数量超过了 `容量 * 0.75` 时（例如容量 16 时，达到 12 个元素就会扩容）。
- **怎么扩容？** 扩容通常是**原容量的 2 倍**。扩容后，需要创建一个新的大数组，并将原数组中的所有元素重新计算位置并迁移到新数组中。
- **Java 8 的巧妙迁移：** 因为容量是 2 的次幂，扩容后，元素在新数组中的位置要么在**原位置**，要么在**原位置 + 旧容量**。`HashMap` 通过检查 `hash & oldCap`（旧容量）是否为 0 来决定元素去哪，这避免了重新计算哈希值的巨大开销。

### 5. 线程安全性

`HashMap` 是**非线程安全**的。在多线程环境下进行 `put` 操作时，可能会导致数据覆盖、甚至在 Java 7 中引发死循环（Java 8 虽然修复了死循环，但仍无法避免数据丢失问题）