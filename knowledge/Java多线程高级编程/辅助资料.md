# Java天生就是多线程语言

- Thread Name: 1 - main
- Thread Name: 2 - Reference Handler
  - 引用处理的线程。强软弱虚
- Thread Name: 3 - Finalizer
  - JVM垃圾回收的相关内容
  - 1. 只要当开始一轮垃圾收集的时候才会调用finalize方法
    2. deamon prio=10 高优先级的守护线程
    3. jvm在垃圾收集的时候，会将失去引用的对象封装到我们的Finalizer对象，放入到F-queue队列中。由Finalizer线程执行Finalize方法
- Thread Name: 4 - Signal Dispatcher 
  - 信号分发器
  - 我们通过cmd发送jstack传到了jvm进程，这时候信号分发器就要发挥作用了
- Thread Name: 5 - Attach Listener
  - 附加监听器
  - 简单来说，他是JDK里面一个工具提供**JVM进程之间通信**的工具
  - jvm --jstack、jmap、dump
  - 开启我们这个线程的方式：
    - 通过jvm参数开启。 -XX:StratAttachListener
    - 延迟开启: cmd java -version --> JVM 适当的时候开启AttachListener线程
- Thread Name: 21 - Common-Cleaner
- Thread Name: 22 - Monitor Ctrl-Break
  - 跟JVM关系不大 
  - IDEA 通过反射的方式开启了一个随着我们运行的JVM进程开启与关闭的监听的线程
  - ![image-20250630201046403](https://gitee.com/mrzengchn/typora-picture/raw/master/upgit/2025/06/20250630_1751285446.png)
- Thread Name: 23 - Notification Thread

```
C:\Users\MrZeng>jstack 4080
2025-06-30 21:02:39
Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.202-b08 mixed mode):

"RMI TCP Connection(2)-192.168.31.111" #25 daemon prio=5 os_prio=0 tid=0x000000002ae48800 nid=0x7360 runnable [0x000000002c0ad000]
   java.lang.Thread.State: RUNNABLE
        at java.net.SocketInputStream.socketRead0(Native Method)
        at java.net.SocketInputStream.socketRead(SocketInputStream.java:116)
        at java.net.SocketInputStream.read(SocketInputStream.java:171)
        at java.net.SocketInputStream.read(SocketInputStream.java:141)
        at java.io.BufferedInputStream.fill(BufferedInputStream.java:246)
        at java.io.BufferedInputStream.read(BufferedInputStream.java:265)
        - locked <0x000000071894cb10> (a java.io.BufferedInputStream)
        at java.io.FilterInputStream.read(FilterInputStream.java:83)
        at sun.rmi.transport.tcp.TCPTransport.handleMessages(TCPTransport.java:555)
        at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run0(TCPTransport.java:834)
        at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.lambda$run$0(TCPTransport.java:688)
        at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler$$Lambda$3/187523448.run(Unknown Source)
        at java.security.AccessController.doPrivileged(Native Method)
        at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run(TCPTransport.java:687)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
        at java.lang.Thread.run(Thread.java:748)

"JMX server connection timeout 24" #24 daemon prio=5 os_prio=0 tid=0x000000002add2800 nid=0x7b30 in Object.wait() [0x000000002b76f000]
   java.lang.Thread.State: TIMED_WAITING (on object monitor)
        at java.lang.Object.wait(Native Method)
        - waiting on <0x000000071821ce90> (a [I)
        at com.sun.jmx.remote.internal.ServerCommunicatorAdmin$Timeout.run(ServerCommunicatorAdmin.java:168)
        - locked <0x000000071821ce90> (a [I)
        at java.lang.Thread.run(Thread.java:748)

"RMI Scheduler(0)" #23 daemon prio=5 os_prio=0 tid=0x000000002add2000 nid=0x32e4 waiting on condition [0x000000002b66f000]
   java.lang.Thread.State: TIMED_WAITING (parking)
        at sun.misc.Unsafe.park(Native Method)
        - parking to wait for  <0x00000007179a4070> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
        at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2078)
        at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:1093)
        at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:809)
        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
        at java.lang.Thread.run(Thread.java:748)

"RMI TCP Connection(1)-192.168.31.111" #22 daemon prio=5 os_prio=0 tid=0x000000002add5000 nid=0x1614 runnable [0x000000002b56e000]
   java.lang.Thread.State: RUNNABLE
        at java.net.SocketInputStream.socketRead0(Native Method)
        at java.net.SocketInputStream.socketRead(SocketInputStream.java:116)
        at java.net.SocketInputStream.read(SocketInputStream.java:171)
        at java.net.SocketInputStream.read(SocketInputStream.java:141)
        at java.io.BufferedInputStream.fill(BufferedInputStream.java:246)
        at java.io.BufferedInputStream.read(BufferedInputStream.java:265)
        - locked <0x00000007181a5238> (a java.io.BufferedInputStream)
        at java.io.FilterInputStream.read(FilterInputStream.java:83)
        at sun.rmi.transport.tcp.TCPTransport.handleMessages(TCPTransport.java:555)
        at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run0(TCPTransport.java:834)
        at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.lambda$run$0(TCPTransport.java:688)
        at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler$$Lambda$3/187523448.run(Unknown Source)
        at java.security.AccessController.doPrivileged(Native Method)
        at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run(TCPTransport.java:687)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
        at java.lang.Thread.run(Thread.java:748)

"RMI TCP Accept-0" #21 daemon prio=5 os_prio=0 tid=0x000000002adda000 nid=0x5d98 runnable [0x000000002b46e000]
   java.lang.Thread.State: RUNNABLE
        at java.net.DualStackPlainSocketImpl.accept0(Native Method)
        at java.net.DualStackPlainSocketImpl.socketAccept(DualStackPlainSocketImpl.java:131)
        at java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:409)
        at java.net.PlainSocketImpl.accept(PlainSocketImpl.java:199)
        - locked <0x0000000717e14538> (a java.net.SocksSocketImpl)
        at java.net.ServerSocket.implAccept(ServerSocket.java:545)
        at java.net.ServerSocket.accept(ServerSocket.java:513)
        at sun.management.jmxremote.LocalRMIServerSocketFactory$1.accept(LocalRMIServerSocketFactory.java:52)
        at sun.rmi.transport.tcp.TCPTransport$AcceptLoop.executeAcceptLoop(TCPTransport.java:405)
        at sun.rmi.transport.tcp.TCPTransport$AcceptLoop.run(TCPTransport.java:377)
        at java.lang.Thread.run(Thread.java:748)

"Service Thread" #19 daemon prio=9 os_prio=0 tid=0x00000000281bd800 nid=0x1a88 runnable [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

"C1 CompilerThread11" #18 daemon prio=9 os_prio=2 tid=0x000000002814a800 nid=0x7870 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

"C1 CompilerThread10" #17 daemon prio=9 os_prio=2 tid=0x0000000028150000 nid=0x6b4c waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

"C1 CompilerThread9" #16 daemon prio=9 os_prio=2 tid=0x000000002814c800 nid=0x83e0 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

"C1 CompilerThread8" #15 daemon prio=9 os_prio=2 tid=0x000000002814d800 nid=0x8498 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

"C2 CompilerThread7" #14 daemon prio=9 os_prio=2 tid=0x000000002814f000 nid=0x6014 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

"C2 CompilerThread6" #13 daemon prio=9 os_prio=2 tid=0x0000000028133000 nid=0x7460 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

"C2 CompilerThread5" #12 daemon prio=9 os_prio=2 tid=0x000000002810e800 nid=0x5580 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

"C2 CompilerThread4" #11 daemon prio=9 os_prio=2 tid=0x00000000280db800 nid=0x6b58 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

"C2 CompilerThread3" #10 daemon prio=9 os_prio=2 tid=0x00000000280c7000 nid=0x2c3c waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

"C2 CompilerThread2" #9 daemon prio=9 os_prio=2 tid=0x00000000280c6000 nid=0x3998 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

"C2 CompilerThread1" #8 daemon prio=9 os_prio=2 tid=0x00000000280c2800 nid=0x78e8 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

"C2 CompilerThread0" #7 daemon prio=9 os_prio=2 tid=0x00000000280c1800 nid=0x4ab0 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

"Monitor Ctrl-Break" #6 daemon prio=5 os_prio=0 tid=0x00000000280bf800 nid=0x342c runnable [0x0000000029c6e000]
   java.lang.Thread.State: RUNNABLE
        at java.net.SocketInputStream.socketRead0(Native Method)
        at java.net.SocketInputStream.socketRead(SocketInputStream.java:116)
        at java.net.SocketInputStream.read(SocketInputStream.java:171)
        at java.net.SocketInputStream.read(SocketInputStream.java:141)
        at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284)
        at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326)
        at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178)
        - locked <0x0000000716acfa30> (a java.io.InputStreamReader)
        at java.io.InputStreamReader.read(InputStreamReader.java:184)
        at java.io.BufferedReader.fill(BufferedReader.java:161)
        at java.io.BufferedReader.readLine(BufferedReader.java:324)
        - locked <0x0000000716acfa30> (a java.io.InputStreamReader)
        at java.io.BufferedReader.readLine(BufferedReader.java:389)
        at com.intellij.rt.execution.application.AppMainV2$1.run(AppMainV2.java:31)

"Attach Listener" #5 daemon prio=5 os_prio=2 tid=0x0000000028080000 nid=0x73a4 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

"Signal Dispatcher" #4 daemon prio=9 os_prio=2 tid=0x000000002807d000 nid=0x3240 runnable [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

"Finalizer" #3 daemon prio=8 os_prio=1 tid=0x00000000265b5000 nid=0x3028 in Object.wait() [0x000000002996f000]
   java.lang.Thread.State: WAITING (on object monitor)
        at java.lang.Object.wait(Native Method)
        - waiting on <0x0000000716808ed0> (a java.lang.ref.ReferenceQueue$Lock)
        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144)
        - locked <0x0000000716808ed0> (a java.lang.ref.ReferenceQueue$Lock)
        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165)
        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:216)

"Reference Handler" #2 daemon prio=10 os_prio=2 tid=0x0000000028006000 nid=0x85fc in Object.wait() [0x000000002986f000]
   java.lang.Thread.State: WAITING (on object monitor)
        at java.lang.Object.wait(Native Method)
        - waiting on <0x0000000716806bf8> (a java.lang.ref.Reference$Lock)
        at java.lang.Object.wait(Object.java:502)
        at java.lang.ref.Reference.tryHandlePending(Reference.java:191)
        - locked <0x0000000716806bf8> (a java.lang.ref.Reference$Lock)
        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)

"main" #1 prio=5 os_prio=0 tid=0x00000000030a4000 nid=0x77f8 waiting on condition [0x0000000002aff000]
   java.lang.Thread.State: TIMED_WAITING (sleeping)
        at java.lang.Thread.sleep(Native Method)
        at org.example.Main.main(Main.java:16)

"VM Thread" os_prio=2 tid=0x00000000265a6000 nid=0x83f0 runnable

"GC task thread#0 (ParallelGC)" os_prio=0 tid=0x00000000030b8800 nid=0x7c0 runnable

"GC task thread#1 (ParallelGC)" os_prio=0 tid=0x00000000030ba000 nid=0xc0 runnable

"GC task thread#2 (ParallelGC)" os_prio=0 tid=0x00000000030bc000 nid=0x5fe4 runnable

"GC task thread#3 (ParallelGC)" os_prio=0 tid=0x00000000030be800 nid=0x8bd0 runnable

"GC task thread#4 (ParallelGC)" os_prio=0 tid=0x00000000030c0800 nid=0x6140 runnable

"GC task thread#5 (ParallelGC)" os_prio=0 tid=0x00000000030c2000 nid=0x8a98 runnable

"GC task thread#6 (ParallelGC)" os_prio=0 tid=0x00000000030c5000 nid=0x55bc runnable

"GC task thread#7 (ParallelGC)" os_prio=0 tid=0x00000000030c6000 nid=0x74d8 runnable

"GC task thread#8 (ParallelGC)" os_prio=0 tid=0x00000000030c7800 nid=0x70d0 runnable

"GC task thread#9 (ParallelGC)" os_prio=0 tid=0x00000000030c8800 nid=0x4270 runnable

"GC task thread#10 (ParallelGC)" os_prio=0 tid=0x00000000030c9800 nid=0x6044 runnable

"GC task thread#11 (ParallelGC)" os_prio=0 tid=0x00000000030cd000 nid=0x7a90 runnable

"GC task thread#12 (ParallelGC)" os_prio=0 tid=0x00000000030ce000 nid=0x5abc runnable

"VM Periodic Task Thread" os_prio=2 tid=0x00000000281a9800 nid=0x694 waiting on condition

JNI global references: 334
```

# 线程的优先级和守护线程

## 线程优先级

优先级在1~10之间

默认的优先级是5

优先级高的线程分配的CPU时间片段就多

setPriority这个方法是Jvm提供的一个方法，并且能够调用，本地方法setPriority0.

- 我们现在的计算机都是多核的，t1 t2 会让哪个cpu处理不好说。由不同的Cpu同时提供资源执行
- 优先级不代表先后顺序。优先级低也有可能先拿到Cpu时间片，只不过这个时间片比高优先级的时间片短
- 优先级针对的是Cpu时间片的长短的问题
- 目前工作中，实际项目里，不必要使用setPriority方法。现在都是使用hystrix，sintial一些开源的信号量工具，都能够实现线程的合理调度。

## 守护线程

![image-20250630211829547](https://gitee.com/mrzengchn/typora-picture/raw/master/upgit/2025/06/20250630_1751289509.png)

```Java
package org.example;

/**
 * ThreadDaemon
 *
 * @author MrZeng
 * @date 2025/06/30
 */

public class ThreadDaemon {
    public static void main(String[] args) {
        Thread thread = new Thread(new DaemonThread(),"DaemonThread");
        thread.setDaemon(true); // 设置为守护线程
        thread.start();

        // mian 线程退出
    }

    static class DaemonThread extends Thread {
        @Override
        public void run() {
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }finally { // finally 不能保证我们的守护线程的执行
                System.out.println("FINISHED");
            }

        }
    }
}

```

```Java
public final void setDaemon(boolean on) {
    checkAccess();
    if (isAlive()) {
        // 告诉我们必须先设置线程是否为守护线程，然后在调用Start方法。如果先调用Start
        throw new IllegalThreadStateException();
    }
    daemon = on;
}
```

# 线程状态的转化

![image-20250630212603704](https://gitee.com/mrzengchn/typora-picture/raw/master/upgit/2025/06/20250630_1751289963.png)

```Java
public enum State {
    /**
     * Thread state for a thread which has not yet started.
     */
    NEW,

    /**
     * Thread state for a runnable thread.  A thread in the runnable
     * state is executing in the Java virtual machine but it may
     * be waiting for other resources from the operating system
     * such as processor.
     */
    RUNNABLE, // （RUNNING <=> READY）

    /**
     * Thread state for a thread blocked waiting for a monitor lock.
     * A thread in the blocked state is waiting for a monitor lock
     * to enter a synchronized block/method or
     * reenter a synchronized block/method after calling
     * {@link Object#wait() Object.wait}.
     */
    BLOCKED,

    /**
     * Thread state for a waiting thread.
     * A thread is in the waiting state due to calling one of the
     * following methods:
     * <ul>
     *   <li>{@link Object#wait() Object.wait} with no timeout</li>
     *   <li>{@link #join() Thread.join} with no timeout</li>
     *   <li>{@link LockSupport#park() LockSupport.park}</li>
     * </ul>
     *
     * <p>A thread in the waiting state is waiting for another thread to
     * perform a particular action.
     *
     * For example, a thread that has called <tt>Object.wait()</tt>
     * on an object is waiting for another thread to call
     * <tt>Object.notify()</tt> or <tt>Object.notifyAll()</tt> on
     * that object. A thread that has called <tt>Thread.join()</tt>
     * is waiting for a specified thread to terminate.
     */
    WAITING,

    /**
     * Thread state for a waiting thread with a specified waiting time.
     * A thread is in the timed waiting state due to calling one of
     * the following methods with a specified positive waiting time:
     * <ul>
     *   <li>{@link #sleep Thread.sleep}</li>
     *   <li>{@link Object#wait(long) Object.wait} with timeout</li>
     *   <li>{@link #join(long) Thread.join} with timeout</li>
     *   <li>{@link LockSupport#parkNanos LockSupport.parkNanos}</li>
     *   <li>{@link LockSupport#parkUntil LockSupport.parkUntil}</li>
     * </ul>
     */
    TIMED_WAITING,

    /**
     * Thread state for a terminated thread.
     * The thread has completed execution.
     */
    TERMINATED;
}
```

